<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sonno x World</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.13.0/dist/tf.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
  <style>
    :root {
      --bg:#f9f9f8;
      --bg-2:#eef1ff;
      --pane:rgba(255,255,255,0.88);
      --border:rgba(15,17,26,0.12);
      --border-strong:rgba(15,17,26,0.18);
      --text:#0f111a;
      --muted:#5f636c;
      --accent:#6fdbed;
      --accent-soft:#6fdbed;
      --radius:28px;
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    body{
      font-family:'Inter','Helvetica Neue',Arial,sans-serif;
      color:var(--text);
      background:linear-gradient(140deg,rgba(111,219,237,0.22) 0%,var(--bg) 42%,rgba(111,219,237,0.16) 100%);
      min-height:100vh;
      display:flex;
      justify-content:center;
      position:relative;
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      background-image:radial-gradient(circle at 12% -10%,rgba(111,219,237,0.2) 0%,transparent 40%),
                       radial-gradient(circle at 85% 0%,rgba(111,219,237,0.24) 0%,transparent 48%);
      pointer-events:none;
      opacity:0.85;
    }
    body::after{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'%3E%3Cfilter id='n'%3E%3CfeTurbulence baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='160' height='160' filter='url(%23n)' opacity='0.22'/%3E%3C/svg%3E");
      mix-blend-mode:soft-light;
      opacity:0.28;
    }
    main{
      width:min(1160px,100%);
      padding:80px 24px 120px;
      display:flex;
      flex-direction:column;
      gap:56px;
      position:relative;
      z-index:1;
    }
    header{
      display:flex;
      flex-direction:column;
      gap:18px;
      max-width:720px;
    }
    .eyebrow{
      font-size:13px;
      letter-spacing:0.32em;
      text-transform:uppercase;
      color:var(--muted);
    }
    header h1{
      font-size:clamp(52px,8vw,104px);
      line-height:1.02;
      font-weight:600;
      letter-spacing:-0.02em;
    }
    .lede{
      font-size:clamp(18px,2.5vw,22px);
      color:var(--muted);
      max-width:560px;
      line-height:1.5;
    }
    .panel{
      background:var(--pane);
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:34px;
      box-shadow:0 38px 90px rgba(15,17,26,0.08), inset 0 1px 0 rgba(255,255,255,0.55);
      backdrop-filter:blur(28px);
    }
    .experience-panel{display:flex;flex-direction:column;gap:32px;}
    .camera-stack{display:flex;flex-direction:column;gap:18px;align-items:stretch;}
    .camera-frame{
      position:relative;
      width:100%;
      aspect-ratio:16/9;
      overflow:hidden;
    }
    video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1);display:block;}
    .overlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      padding:20px 24px;
      background:linear-gradient(180deg,rgba(249,249,248,0) 45%,rgba(249,249,248,0.94) 100%);
    }
    .count{
      font-size:40px;
      font-weight:600;
      display:flex;
      flex-direction:column;
      gap:4px;
      color:var(--text);
    }
    .count span{font-size:64px;line-height:0.95;color:var(--accent);}
    .count small{
      font-size:12px;
      letter-spacing:0.32em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .layers-indicator{font-size:15px;font-weight:500;color:var(--muted);text-align:right;max-width:260px;line-height:1.4;}
    .status{font-size:13px;color:var(--muted);text-align:center;letter-spacing:0.04em;}
    button{
      font-family:inherit;
      border:none;
      cursor:pointer;
    }
    .panel h2{font-size:26px;font-weight:600;margin:0 0 10px;letter-spacing:-0.01em;}
    .panel > p{color:var(--muted);font-size:16px;line-height:1.55;margin-bottom:28px;max-width:620px;}
    .panel-header{display:flex;flex-direction:column;gap:10px;}
    .panel-header p{margin:0;color:var(--muted);font-size:15px;line-height:1.6;max-width:620px;}
    .playback-controls{display:flex;justify-content:flex-end;margin:-10px 0 24px;}
    .ghost-btn{
      padding:12px 22px;
      border-radius:999px;
      border:1px solid rgba(111,219,237,0.42);
      background:rgba(255,255,255,0.9);
      color:var(--text);
      font-weight:600;
      letter-spacing:0.14em;
      text-transform:uppercase;
      font-size:11px;
      transition:background .2s ease,color .2s ease,box-shadow .2s ease;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:48px;
      height:48px;
      padding:0;
    }
    .ghost-btn:hover:not([disabled]){background:rgba(111,219,237,0.12);color:var(--text);box-shadow:0 12px 26px rgba(111,219,237,0.18);}
    .ghost-btn[disabled]{opacity:.45;cursor:not-allowed;border-color:rgba(111,219,237,0.24);}
    .songs{
      display:grid;
      gap:22px;
      grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    }
    .song-card{
      position:relative;
      padding:26px;
      border-radius:calc(var(--radius) - 10px);
      background:rgba(255,255,255,0.94);
      border:1px solid var(--border);
      box-shadow:0 24px 60px rgba(15,17,26,0.08);
      display:flex;
      flex-direction:column;
      gap:18px;
      transition:border-color .2s ease,box-shadow .2s ease,transform .2s ease;
    }
    .song-card h3{font-size:20px;font-weight:600;}
    .song-card button{
      align-self:flex-start;
      padding:13px 22px;
      border-radius:999px;
      border:1px solid var(--border-strong);
      background:rgba(255,255,255,0.85);
      color:var(--text);
      font-weight:500;
      letter-spacing:0.04em;
      text-transform:uppercase;
      font-size:12px;
      transition:background .2s ease,color .2s ease,box-shadow .2s ease,border-color .2s ease;
    }
    .song-card button:is(:hover,.is-active){
      background:linear-gradient(120deg,var(--accent),rgba(111,219,237,0.8));
      color:#0f111a;
      border-color:transparent;
      box-shadow:0 16px 32px rgba(111,219,237,0.26);
    }
    .song-card.active{
      border-color:var(--accent);
      box-shadow:0 28px 60px rgba(111,219,237,0.24);
      transform:translateY(-3px);
    }
    footer{font-size:12px;color:var(--muted);text-align:center;letter-spacing:0.18em;text-transform:uppercase;}
    @media(max-width:820px){
      main{gap:48px;padding:64px 20px 96px;}
      .panel{padding:28px;}
      .camera-stack{gap:20px;}
      .layers-indicator{text-align:left;max-width:none;}
      .overlay{flex-direction:column;align-items:flex-start;gap:12px;}
    }
    @media(max-width:540px){
      header h1{font-size:clamp(42px,11vw,64px);}
      .song-card{padding:22px;}
    }
  </style>
</head>
<body>
  <main>
    <header>
      <span class="eyebrow">World protocol experience</span>
      <h1>Sonno x World</h1>
      <p class="lede">A layered soundscape that senses presence, unlocking new stems as the crowd gathers.</p>
    </header>

    <section class="panel experience-panel">
      <div class="camera-stack">
        <div class="camera-frame">
          <video id="webcam" autoplay playsinline muted></video>
          <div class="overlay">
            <div class="count"><span id="people-count">0</span><small>people in frame</small></div>
            <div class="layers-indicator" id="layers-indicator">Select a song to start playback.</div>
          </div>
        </div>
        <p class="status" id="camera-status">Camera idle. Choose a song to activate detection.</p>
      </div>

      <div class="panel-header">
        <h2>Pick a song</h2>
        <p>0 people = core stem only · 1 person = add layers 1 &amp; 2 · 2 people = add layer 3 · 3+ people = every layer.</p>
      </div>

      <div class="playback-controls">
        <button type="button" id="toggle-playback" class="ghost-btn" disabled aria-label="Pause audio"></button>
      </div>
      <div class="songs">
        <article class="song-card" data-song-id="world-1"
                 data-base="assets/audio/World%201/World%201%20(Drums).mp3|assets/audio/World%201/World%201%20(Synth).mp3"
                 data-group1="assets/audio/World%201/World%201%20(Percussion).mp3|assets/audio/World%201/World%201%20(Strings).mp3"
                 data-group2="assets/audio/World%201/World%201%20(Keyboard).mp3|assets/audio/World%201/World%201%20(FX).mp3"
                 data-group3="assets/audio/World%201/World%201%20(Vocals).mp3|assets/audio/World%201/World%201%20(Backing%20Vocals).mp3">
          <h3>World 1</h3>
          <button type="button" class="select-song">Play World 1</button>
        </article>

        <article class="song-card" data-song-id="world-2"
                 data-base="assets/audio/World%202/Close%20Enough%20to%20Touch%20(Bass).mp3|assets/audio/World%202/Close%20Enough%20to%20Touch%20(Drums).mp3"
                 data-group1="assets/audio/World%202/Close%20Enough%20to%20Touch%20(Percussion).mp3|assets/audio/World%202/Close%20Enough%20to%20Touch%20(Synth).mp3"
                 data-group2="assets/audio/World%202/Close%20Enough%20to%20Touch%20(Guitar).mp3|assets/audio/World%202/Close%20Enough%20to%20Touch%20(Strings).mp3"
                 data-group3="assets/audio/World%202/Close%20Enough%20to%20Touch%20(Vocals).mp3|assets/audio/World%202/Close%20Enough%20to%20Touch%20(FX).mp3">
          <h3>Close Enough to Touch</h3>
          <button type="button" class="select-song">Play Close Enough to Touch</button>
        </article>

        <article class="song-card" data-song-id="world-3"
                 data-base="assets/audio/World%203/Paper%20Birds%20(Bass).mp3|assets/audio/World%203/Paper%20Birds%20(Drums).mp3"
                 data-group1="assets/audio/World%203/Paper%20Birds%20(Percussion).mp3|assets/audio/World%203/Paper%20Birds%20(Keyboard).mp3"
                 data-group2="assets/audio/World%203/Paper%20Birds%20(Strings).mp3|assets/audio/World%203/Paper%20Birds%20(Synth).mp3"
                 data-group3="assets/audio/World%203/Paper%20Birds%20(Vocals).mp3|assets/audio/World%203/Paper%20Birds%20(FX).mp3">
          <h3>Paper Birds</h3>
          <button type="button" class="select-song">Play Paper Birds</button>
        </article>
      </div>
    </section>

    <footer>Built for Sonno ∞ World — keep headphones handy.</footer>
  </main>

  <script>
    const video = document.getElementById('webcam');
    const statusEl = document.getElementById('camera-status');
    const countEl = document.getElementById('people-count');
    const layersEl = document.getElementById('layers-indicator');
    const togglePlaybackBtn = document.getElementById('toggle-playback');

    let model = null;
    let stream = null;
    let detectionTimer = null;
    let cameraStartPromise = null;
    let peopleCount = 0;

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const masterGain = audioContext.createGain();
    masterGain.gain.value = 1;
    masterGain.connect(audioContext.destination);
    const songs = new Map();
    let activeSong = null;
    let isPaused = false;

    const pauseIcon = '<svg width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg" fill="none"><rect x="4" y="3" width="3" height="12" rx="1" fill="currentColor"/><rect x="11" y="3" width="3" height="12" rx="1" fill="currentColor"/></svg>';
    const playIcon = '<svg width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg" fill="none"><path d="M6.25 3.7c0-.78.85-1.26 1.52-.84l7 4.3c.66.4.66 1.36 0 1.76l-7 4.3a1 1 0 0 1-1.52-.84V3.7Z" fill="currentColor"/></svg>';

    class LoopPlayer {
      constructor(context, url, outputNode) {
        this.context = context;
        this.url = url;
        this.buffer = null;
        this.source = null;
        this.gain = context.createGain();
        this.outputNode = outputNode || context.destination;
        this.gain.connect(this.outputNode);
        this.gain.gain.value = 0;
      }
      async load() {
        const response = await fetch(this.url);
        if (!response.ok) throw new Error('Failed to load audio: ' + this.url);
        const data = await response.arrayBuffer();
        this.buffer = await this.context.decodeAudioData(data);
      }
      ensureSource() {
        if (this.source || !this.buffer) return;
        const node = this.context.createBufferSource();
        node.buffer = this.buffer;
        node.loop = true;
        node.connect(this.gain);
        node.start();
        this.source = node;
      }
      setActive(active, smooth = true) {
        this.ensureSource();
        const now = this.context.currentTime;
        this.gain.gain.cancelScheduledValues(now);
        if (!smooth) {
          this.gain.gain.setValueAtTime(active ? 1 : 0, now);
          return;
        }
        const target = active ? 1 : 0;
        const duration = active ? 1.5 : 0.5;
        this.gain.gain.setValueAtTime(this.gain.gain.value, now);
        this.gain.gain.linearRampToValueAtTime(target, now + duration);
      }
      stop() {
        const now = this.context.currentTime;
        this.gain.gain.cancelScheduledValues(now);
        this.gain.gain.setValueAtTime(0, now);
        if (this.source) {
          try { this.source.stop(); } catch (_) {}
          this.source.disconnect();
          this.source = null;
        }
      }
    }

    class SongLayers {
      constructor(context, card) {
        this.context = context;
        this.card = card;
        const dataset = card.dataset;
        const baseSources = dataset.base ? dataset.base.split('|').map(s => s.trim()).filter(Boolean)
          : (dataset.core ? [dataset.core] : []);
        this.basePlayers = baseSources.map(src => new LoopPlayer(context, src, masterGain));
        const groupKeys = Object.keys(dataset)
          .filter(key => /^group\d+$/.test(key))
          .sort((a, b) => Number(a.replace('group', '')) - Number(b.replace('group', '')));
        this.layerGroups = groupKeys.map(key => {
          return dataset[key]
            .split('|')
            .map(s => s.trim())
            .filter(Boolean)
            .map(src => new LoopPlayer(context, src, masterGain));
        });
        this.ready = false;
      }
      async load() {
        if (this.ready) return;
        const players = [
          ...this.basePlayers,
          ...this.layerGroups.flat()
        ];
        await Promise.all(players.map(p => p.load()));
        this.ready = true;
      }
      applyCount(count) {
        const groupsToActivate = Math.min(this.layerGroups.length, Math.max(0, count));
        const addedStemCount = this.layerGroups
          .slice(0, groupsToActivate)
          .reduce((sum, group) => sum + group.length, 0);
        if (!this.ready) {
          return {
            activeGroups: groupsToActivate,
            totalGroups: this.layerGroups.length,
            baseCount: this.basePlayers.length,
            addedStems: addedStemCount
          };
        }
        this.basePlayers.forEach(player => player.setActive(true, false));
        this.layerGroups.forEach((group, index) => {
          const shouldPlay = index < groupsToActivate;
          group.forEach(player => player.setActive(shouldPlay, true));
        });
        return {
          activeGroups: groupsToActivate,
          totalGroups: this.layerGroups.length,
          baseCount: this.basePlayers.length,
          addedStems: addedStemCount
        };
      }
      stop() {
        [...this.basePlayers, ...this.layerGroups.flat()].forEach(player => player.stop());
      }
    }

    function formatLayerStatus(activeGroups, totalGroups, baseCount, addedStems) {
      if (totalGroups === 0) {
        return baseCount > 0 ? 'Base stems active' : 'No stems loaded';
      }
      if (activeGroups === 0) {
        return baseCount > 0 ? 'Base stems only' : 'No stems active';
      }
      if (activeGroups >= totalGroups) {
        return 'All stems active';
      }
      return `Base + ${addedStems} added stems`;
    }

    document.querySelectorAll('.song-card').forEach(card => {
      const song = new SongLayers(audioContext, card);
      songs.set(card.dataset.songId, song);
      const button = card.querySelector('.select-song');
      button.addEventListener('click', async () => {
        try {
          await ensureCameraStarted();
          await audioContext.resume();
          if (!song.ready) {
            button.textContent = 'Loading…';
            await song.load();
          }
          if (activeSong && activeSong !== song) {
            activeSong.stop();
            activeSong.card.classList.remove('active');
            const prevButton = activeSong.card.querySelector('button');
            prevButton.classList.remove('is-active');
            prevButton.textContent = `Play ${activeSong.card.querySelector('h3').textContent}`;
          }
          activeSong = song;
          card.classList.add('active');
          button.classList.add('is-active');
          button.textContent = 'Now playing';
          togglePlaybackBtn.disabled = false;
          updateToggleButton();
          if (isPaused) {
            statusEl.textContent = 'Audio paused. Press Resume to play.';
          }
          applyPeopleCount(peopleCount);
        } catch (err) {
          console.error(err);
          statusEl.textContent = 'Audio error: ' + err.message;
        }
      });
    });

    function applyPeopleCount(count) {
      peopleCount = count;
      countEl.textContent = count;
      if (!activeSong) {
        layersEl.textContent = 'Select a song to start playback.';
        return;
      }
      const { activeGroups, totalGroups, baseCount, addedStems } = activeSong.applyCount(count);
      layersEl.textContent = formatLayerStatus(activeGroups, totalGroups, baseCount, addedStems);
      if (!isPaused) {
        statusEl.textContent = 'Audio playing.';
      }
    }

    function updateToggleButton() {
      togglePlaybackBtn.innerHTML = isPaused ? playIcon : pauseIcon;
      togglePlaybackBtn.setAttribute('aria-label', isPaused ? 'Resume audio' : 'Pause audio');
    }

    function setPaused(paused) {
      if (paused === isPaused) return;
      isPaused = paused;
      const now = audioContext.currentTime;
      masterGain.gain.cancelScheduledValues(now);
      masterGain.gain.setValueAtTime(masterGain.gain.value, now);
      masterGain.gain.linearRampToValueAtTime(paused ? 0 : 1, now + 0.25);
      updateToggleButton();
      statusEl.textContent = paused ? 'Audio paused.' : 'Audio playing.';
    }

    togglePlaybackBtn.addEventListener('click', () => {
      if (!activeSong) {
        statusEl.textContent = 'Select a song before controlling playback.';
        return;
      }
      setPaused(!isPaused);
    });
    updateToggleButton();

    async function ensureCameraStarted() {
      if (stream) return;
      if (!cameraStartPromise) {
        cameraStartPromise = startCamera().finally(() => {
          cameraStartPromise = null;
        });
      }
      return cameraStartPromise;
    }

    async function startCamera() {
      if (stream) return;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
        video.srcObject = stream;
        statusEl.textContent = 'Camera active. Analysing…';
        await loadModel();
        scheduleDetection();
      } catch (err) {
        statusEl.textContent = 'Camera error: ' + err.message;
      }
    }

    async function loadModel() {
      if (!model) {
        statusEl.textContent = 'Loading detection model…';
        model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
        statusEl.textContent = 'Model ready. Step into frame to add layers.';
      }
    }

    async function analyze() {
      if (!model || video.readyState < 2) return;
      const predictions = await model.detect(video);
      const count = predictions.filter(p => p.class === 'person' && p.score >= 0.55).length;
      applyPeopleCount(count);
    }

    function scheduleDetection() {
      clearTimeout(detectionTimer);
      detectionTimer = setTimeout(async () => {
        try {
          await analyze();
        } catch (err) {
          console.error(err);
        }
        scheduleDetection();
      }, 260);
    }

    window.addEventListener('beforeunload', () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      songs.forEach(song => song.stop());
      audioContext.close();
    });
  </script>
</body>
</html>
